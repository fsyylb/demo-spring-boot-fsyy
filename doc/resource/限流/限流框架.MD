java 的限流框架 限流框架有几种 


一、简介
为什么要限流呢？限流是为了保证系统的整体稳定性，若大量请求超过微服务的处理能力，可能导致服务会被击垮，严重者产生雪崩效应或服务器宕机。高并发下为了保证系统的稳定运行，除了限流还有缓存和降级这些常用的解决方案。

二、常用限流框架
guava：google的guava工具包中就提供了限流工具类 RateLimiter,RateLimiter是基于令牌通算法来实现限流的。
hystrix：hystrix主要是通过资源池以及信号量来限流，暂时能支持简单的限流
sentinel：Sentinel采用滑动窗口算法来实现限流。当然sentinel不仅仅局限于限流，它是一个面向分布式服务架构的高可用流量防护组件，主要以流量为切入点，从限流、流量整形、熔断降级、系统负载保护、热点防护等多个维度来帮助开发者保障微服务的稳定性。
nginx限流：nginx限流方式有limit_conn_zone(限定IP最大连接数)、limit_req_zone(限定IP最大请求数)、ngx_http_upstream_module(反向代理中max_conns可以限制连接数)，但是nginx限流不够灵活，不好动态配置
网关限流：常用的网关有gateway和zuul，在gateway问世之前，网关一般使用的是zuul,但zuul存在一些问题，比如阻塞式的 API，不支持 WebSocket等。所以后面基本都使用gateway作为网关 。
gateway：基于其内置的过滤器工厂RequestRateLimiterGatewayFilterFactory实现，在过滤器工厂中是通过Redis和lua脚本结合的方式进行流量控制
算法：令牌桶
限流服务：单个服务模块
限流对象：
请求频率限流（Request rate limiting）：限制某个接口的一分钟内的请求数
并发量限流（Concurrent requests limiting）：限制某个服务的处理请求数
传输速率限流（Transmission rate limiting）：限制下载文件速率
限制黑名单用户访问
限制某个IP请求
zuul：
算法： 漏桶、令牌桶
限流服务：整个网关或单个服务模块
限流对象：
user：认证用户或者匿名，针对某个用户粒度进行限流
origin：客户机的IP,针对请求客户机的IP进行限流
url：特定url,针对请求的url粒度进行限流
serviceId：特定服务，针对某个服务的id粒度进行限流
三、限流算法(两窗两桶)
固定窗口计数器算法：窗口(一个时间段)内请求数不超过限流数，超过了则丢弃之后的请求，待下一个窗口重新计算
优点：和漏桶相比，能够处理突发流量
缺点：1. 在窗口的起始时间，最差情况下可能会带来 2 倍的流量，可能压垮服务 2. 很多消费者可能都在等待窗口被重置，造成惊群效应
滑动窗口计算器算法：以当前时间为截止时间，往前取一个固定的时长作为一个周期，例如该周期为10s，在当前时到前10s内请求数超过了限流数则拒绝请求，当时间窗口往后滑动一次，则重新计算一次
优点：1. 避免了漏桶算法带来的饥饿问题 2. 避免了固定窗口算法的请求量突增的问题
缺点：当滑动窗口的格子划分的越多，占用的空间资源就越大
漏桶算法：将每个请求加入漏桶进行存储，漏桶以固定速率匀速处理请求，若桶满则抛弃请求。其底层结构是个队列，当请求到来时，不是直接处理，而是放入队列中，另一个线程以固定的速率从队列读取请求，从而达到限流的目的。
优点：能够平滑请求数，使系统以一个均匀的速率处理请求
缺点：无法处理突发流量
令牌桶算法：以固定速度往令牌桶中放入令牌，当有请求过来时必须在桶中获取令牌才能处理请求，如果没有令牌则请求拒绝或阻塞，所以桶内令牌越多瞬时间可以处理更多请求，但如果令牌桶容量设置不合理超过了服务所能承受的极限，可能会导致服务瘫痪。单机情况下可以使用AtomicLong 作为令牌桶来实现，对其进行CAS加操作与CAS减操作(也就是令牌桶令牌的放入与拿取)，以避免线程的上下文切换的开销。如果是分布式情况下则可用redis作为令牌桶方案
特点：可处理突发流量
缺点：当容量设置不合理时，可能压垮服务