### 看了 5 种分布式事务方案，我司最终选择了 Seata，真香！
https://www.cnblogs.com/chengxy-nds/p/14046856.html

对比 7 种分布式事务方案，阿里的 Seata 真香！(原理+实战)
https://cloud.tencent.com/developer/article/1975104


各大分布式事务框架对比 #626
名词解释:

数据库有六种日志分别是：重做日志(redo log)、回滚日志(undo log)、二进制日志(binlog)、错误日志(errorlog)、 慢查询日志(slow query log)、一般查询日志(general log)，中继日志(relay log)

事务类型: XA 因为 事务资源 感知并参与分布式事务处理过程，所以 事务资源（如数据库）可以保障从任意视角对数据的访问有效隔离，满足全局数据一致性。而TCC,Saga,AT属于补偿型事务

补偿型事务: 在一个长事务（ long-running ）中 ，一个由两台服务器一起参与的事务，服务器A发起事务，服务器B参与事务，B的事务需要人工参与，所以处理时间可能很长。如果按照ACID的原则，要保持事务的隔离性、一致性，服务器A中发起的事务中使用到的事务资源将会被锁定，不允许其他应用访问到事务过程中的中间结果，直到整个事务被提交或者回滚。这就造成事务A中的资源被长时间锁定，系统的可用性将不可接受。
目前一个叫WS-BusinessActivity的组织提供了一种基于补偿的long-running的事务处理模型。服务器A的事务如果执行顺利，那么事务A就先行提交，如果事务B也执行顺利，则事务B也提交，整个事务就算完成。但是如果事务B执行失败，事务B本身回滚，这时事务A已经被提交，所以需要执行一个补偿操作，将已经提交的事务A执行的操作作反操作，恢复到未执行前事务A的状态。这样的事务模型，是牺牲了一定的隔离性和一致性的，但是提高了long-running事务的可用性

ps: 对于MySQL事务 有兴趣可以阅读本人的笔记
以MySQL为例: https://www.yuque.com/chengxingyuan/vffshx/wi7z7y
一般在不同的业务场景应按需引入不同的事务形态 优先级顺序为:
单机事务 > 基于消息的事务 > 基于补偿的事务

功能对比

特性	DTM	SEATA	
支持语言	Golang 、python 、php 、c# 及其他	Java	
异常处理	子事务屏障自动处理	事务异常切面拦截，对于数据库连接超时，各个tm时区不一致等外部问题 需要手动处理	
TCC 事务	✓	✓	
XA 事务	✓	✓	
AT 事务	✗	✓	
SAGA 事务	简单模式	状态机复杂模式	
事务消息(可靠消息模式)	✓	✗	
通信协议	HTTP 、GRPC	四层私有协议	
事务模式横向对比

特性	MySQL XA	Postgresql XA	LCN 模式	AT 模式	RT 模式
支持语言	无限制		Java	Java	PHP
使用难度	简单		困难	困难	简单
数据一致性	100%		强	中	100%
并发性能	中		低	中	高
业务入侵	无		无	低	无
sql 修复入侵	无		无	低	无
分布式事务嵌套	不支持		支持	支持	支持
子服务嵌套事务	不支持		不支持	不支持	支持
sql 事务嵌套	支持		不支持	不支持	支持
通信协议	不能跨服务		dubbo	dubbo	http
事务隔离级别	可重复读		未知	读未提交	读已提交
事务类型	长事务		长事务	短事务	短事务
死锁	多		多	少	少
orm 框架	适用		绑定	绑定	适用
支持 sql 语句	所有		未知	不支持多表和批量操作	绝大部分
脏回滚	无				
存在					
脏读	无				
有					
各个事务模式下的对比

所以接下来的对比会涉及到每个框架各个隔离级别的对比

隔离级别/发生情况	XA	TCC	Saga
SERIALIZABLE级别	读操作加读锁、写操作加写锁		
|
|
| REPEATABLE READ级别 | 读是本地多版本不是全局多版本(脏读) |
|
|
| READ COMMITTED级别 |
|
| |
| READ UNCOMMITTED级别 |
|
| |

Continue..QwQ

### 分布式事务选型及对比
https://juejin.cn/post/7054825125312495630

分布式事务—LCN原理及使用方式
https://zhuanlan.zhihu.com/p/325602044

基于RocketMQ分布式事务 - 完整示例
https://zhuanlan.zhihu.com/p/115553176


那解决分布式事务该选用那种框架呢？

首先看是否能扩展机器，在有成本的情况下，尽量考虑mq，毕竟已经帮我们做好了重试，消息持久化等功能
RabbitMQ和RockteMQ选型，尽量采用RocketMQ，RabbitMQ不是用java语言编写，扩展能力比较差，而且抗并发能力与RocktMQ相差很远
lcn和seata之间选型，如果数据需要保证强一致性，就选择lcn。如果不需要，就选择seata。



### 幂等性
MQ系列10：如何保证消息幂等性消费
https://www.cnblogs.com/wzh2010/p/15888523.html

消费消息需要考虑：
会不会重复消费
能不能避免重复消费
重复消费了也别造成系统异常可以吗
使用 MQ 如何保证幂等性也是架构设计考虑的问题。
rabbitmq、rocketmq、kafka，都可能会出现消费重复消费，因为这个问题不是 MQ 自身保证的，是我们开发自己需要保证的。
何时重复消费？
kafka 有个 offset 概念，每个消息写进去，都有一个 offset，代表他的序号，然后 consumer 消费了消息后，每隔一段时间，会把自己消费过的消息的 offset 提交一下，代表我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费。
但凡事有意外，比如重启系统，碰到急的，直接 kill 进程再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset。重启之后，少数消息会再次消费。
其实重复消费不可怕，可怕的是你没考虑到重复消费之后，如何保证幂等性。
比如你有个系统，消费一条往 DB 插一条，要是你一个消息重复两次，你不就插入两条，这数据不就错了？但你要是消费到第二次时，自己判断一下已消费了，直接扔了，不就只保留了一条数据！
一条数据重复出现两次，DB 里就只有一条数据，这就保证了系统的幂等性。
幂等性，就一个数据或一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。
所以
怎么保证消息队列消费的幂等性？
还是得结合业务来思考，大体思路如下：
写 DB，你先根据主键查一下，如果这数据都有了，你就别插入了，update 之
写 redis，那没问题了，反正每次都是 set，天然幂等
其它场景，你需要让生产者发送每条消息时，里面加一个全局唯一 id，然后你这里消费到了之后，先根据这个 id 去 redis 查一下，之前消费过吗？
如果没有消费过你就处理，然后这个 id 写 redis
如果消费过了那你就别处理了，保证别重复处理相同的消息
还有比如基于 DB 的唯一键保证重复数据不会重复插入多条。

### 【全网最通俗】什么是幂等性
先摆结论
幂等性，就是套个个高大上名字的普通概念，根本就不是新概念，甚至你开发时还经常会实现所谓的幂等性。

再详细点
幂等性的通俗概念：
调用方，对一个系统进行重复调用（参数全部相同），不论重复调用多少次，这些调用对系统的影响都是相同的效果。就是不论调用我多少次你对我的影响以及你的影响都是不变的，不会随着次数的变化而改变。

举个简单的例子：
天然幂等性：

假设对象Person中有个name属性，有个

setName(String name){
   this.name = name
}
的方法，那这个方法就是天然幂等的哦，你输入相同的“小明”参数，不论你重复调用多少次都是将名字设置为“小明”，其对对象Person的影响都是一样的。这就是天然幂等性。

非幂等性：
还是拿对象Person举例子，假设对象中有个age属性，有个

increaseAge(){
   this.age++;
}
方法，我们按正常的步骤一次一次调用是不会有问题的，如果调用者没有控制好逻辑，一次流程重复调用好几次，这时候影响效果和一次是有非常大区别，代码编写者以为它只会调用一次，结果出现了意外调用了很多次，恰好方法不具有幂等性，于是就会出现和预期不一样的效果。这个方法本身是不具备幂等性的，我们可以修改这个方法，让其传入一个标识符，每一次重复的请求会有相同的标识符，方法内部可以根据标识符查数据库是不是已经处理过，如果处理过就不重复处理。这样方法就具备了幂等性。

再举个实际点的例子：
客户在进行一笔转账交易，后端划分了两个系统来处理这个转账的流程：

①系统A负责收集转账人和接收人还有金额的信息然后传给系统B进行转账，将控制逻辑留在系统A。

②系统B读取系统A传过来的信息，负责更改数据库的金额。如果操作成功，就回复系统A成功，如果失败就回复系统A失败。

③系统A可以接受系统B操作成功或失败的回复，但是我们知道，系统A这个交易流程是有等待时间的，如果等待超时，它不确认是否是转账成功或失败，于是系统A会重试调用直到得到一个明确的回复。

这是系统大致的交易流程。这个流程是有问题的，系统B提供的操作接口不是幂等性的。

逻辑漏洞：
假设系统B操作成功了，但是由于系统B回复的时候遇到网络抖动、网络阻塞、网络风暴等，这个成功的消息没有及时被系统A接收，系统A再重试让系统B转账，结果会导致：用户点击一次转账，后台为他转了很多笔。这是非常危险的。

解决办法：
我们可以为每一笔用户发起的转账请求赋予一个全局唯一的ID，把这个ID在调用系统B的时候一起传输进去，第一次系统B处理的时候正常处理，处理完之后把转账成功还是失败的状态与ID一起存入数据库，下次重复请求会查找数据库，查出来数据为空则代表第一次请求，查出来状态为成功，则直接返回成功，查出来状态为失败，则再操作一次。这样能确保不会出现上述逻辑错误

总结：
很多方法具有天然的幂等性，有的方法不具备，我们需要业务逻辑层来实现幂等性。我们开发的过程中考虑全面了就能自然的实现幂等性，幂等性根本就不是什么新的知识。


### 分布式事务框架详解(6大分布式事务框架) - mikechen
https://mikechen.cc/27707.html

5大分布式事务框架详解(图文全面总结)
https://blog.itpub.net/70024420/viewspace-3011768/

SpringCloud + RocketMQ 实现分布式事务
https://github.com/yudiandemingzi/spring-cloud-rocketmq-transaction


### 分布式&分布式事务&分布式锁&分布式ID
https://blog.csdn.net/sc179/article/details/132643264